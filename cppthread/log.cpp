// Copyright (c) 2013-2024  Made to Order Software Corp.  All Rights Reserved
//
// https://snapwebsites.org/project/cppthread
// contact@m2osw.com
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License along
// with this program; if not, write to the Free Software Foundation, Inc.,
// 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

/** \file
 * \brief Implementation of the logging facility.
 *
 * The library is very often used by daemons meaning that it will be running
 * on its own in the background. For this reason, all the output is done
 * through the log facility.
 *
 * This interface defines a function which you are expected to call to setup
 * a callback. By default, the callback is set to a function that simply
 * prints errors to std::cerr.
 *
 * \note
 * Note that the log facility is used only in extreme cases. It was made
 * fully thread safe, however, that implementation is considered slow.
 * Especially, if two different threads attempt to log a message
 * simultaneously, only one of them will be allowed to build their
 * message and the other one will be blocked for the entire time. Our
 * snaplogger, on the other hand, allows any number of threads to generate
 * errors in parallel, only the processing at the end, which can be done
 * asynchronously, requires serialization.
 */

// self
//
#include    "cppthread/log.h"

#include    "cppthread/exception.h"


// C++
//
#include    <cstring>
#include    <iostream>


// last include
//
#include    <snapdev/poison.h>



namespace cppthread
{


/** \brief Function used to initialize the system mutex.
 *
 * This is unfortunate, but the system mutex create relies on the log
 * object to exist and be properly initialized before it gets created.
 * So we call this function from the constructor of the logger.
 *
 * \note
 * This means it's not exact _properly initialized_ since the constructor
 * did not yet return. However, it is guaranteed to work properly since
 * we do not allow derivations or virtual tables.
 */
extern void create_system_mutex();


/** \brief The logger object used to send logs out.
 *
 * This object is used to send data to the logger.
 *
 * \note
 * This works because this library does not create a thread on
 * initialization and therefore there is no reason for this
 * library to initiate a logger call. At least, at this time,
 * this is true and I'm not too sure what could generate such
 * a problem.
 */
logger      log;


namespace
{


/** \brief The log callback function.
 *
 * If define (not nullptr), this callback gets called whenever a log
 * message is generated.
 *
 * You are expected to log the message to a file, send over a network,
 * etc. The default (when the pointer is nullptr) is to send the
 * message to std::cerr.
 */
log_callback        g_log_callback = nullptr;


/** \brief The mutex used to ensure proper synchronization.
 *
 * The g_log_mutex variable is used to lock the cppthread logger so
 * functions that need to run in a single thread at a time can run
 * properly.
 */
pthread_mutex_t     g_log_mutex = PTHREAD_MUTEX_INITIALIZER;


/** \brief Whether the lock is currently active.
 *
 * This variable holds true or false. When false, no other thread holds
 * the lock so we are the only one logging data. Once true, we are the
 * one holding the lock if we pass through.
 */
bool                g_log_locked = false;


/** \brief Whether the g_log_recursive_mutex was initialized.
 *
 * Whenever a log message is to be sent, we need a recursive lock
 * to make sure that we can properly lock one or the other thread.
 *
 * This flag tells us whether we still have to initialize the
 * g_log_recursive_mutex variable.
 */
bool                g_log_recursive_initialized = false;


/** \brief We need a recursive lock and can't know whether the default is.
 *
 * In order to implement our lock() properly we need a recursive lock.
 * This variable is used for this purpose. The g_log_mutex is first
 * used to make sure we initialized this recursive lock. Since there
 * is nothing that tells us whether a mutex was initialized we also
 * need a flag: g_log_recursive_initialized.
 *
 * \warning
 * We do not use the cppthread mutex class because it calls us, so we
 * could otherwise end up in an infinite loop.
 */
pthread_mutex_t     g_log_recursive_mutex;


} // no name namespace



/** \brief Set a callback function.
 *
 * Set a callback function used to redirect the logs generated by the
 * cppthread library and any library that makes use of this log
 * facility (i.e. the advgetopt project does so).
 *
 * \note
 * You should not use this facility unless you do not have access to
 * the snaplogger, somehow. The snaplogger is a much more advanced
 * and better interface especially in a multithreaded application.
 *
 * \param[in] callback  The function to call whenever a log is generated.
 */
void set_log_callback(log_callback callback)
{
    pthread_mutex_lock(&g_log_mutex);
    g_log_callback = callback;
    pthread_mutex_unlock(&g_log_mutex);
}


/** \class logger
 * \brief The cppthread logger.
 *
 * The cppthread is a dependency of the snaplogger so we have to have
 * our own logger implementation in this class.
 *
 * This class is very basic. It only supports 5 severity levels and a simple
 * mechanism to write messages to a log file or a callback.
 *
 * \note
 * If you can use the snaplogger library, then you should avoid using
 * this cppthread implementation. The snaplogger will automatically
 * provide a callback to this cppthread implementation and output
 * the logs as required. It's just that the snaplogger is way more
 * powerful.
 * \note
 * This is actually the main reason why the class is marked final.
 */


/** \brief Initialize the logger.
 *
 * The logger makes sure that the system mutex gets allocated. This
 * way if an error occurs in that initialization process, it will
 * happen after the logger gets initialized. Although it can happen
 * before the logger initialization returns, the object initialization
 * is already complete when we reach the call to the
 * create_system_mutex() function.
 */
logger::logger()
{
    try
    {
        create_system_mutex();
    }
    catch(...)
    {
        std::cerr << "fatal: could not create system mutex."
                  << std::endl;
        std::terminate();
    }
}


/** \brief Lock the system so a log can be emitted properly.
 *
 * This function allows the locking of the logger. This ensures that
 * we can use a simple object even in a multithread environment. The
 * only potential problem now is a deadlock.
 *
 * Note that you may call the lock() function any number of times. It
 * will not count the number of calls. It locks only once. If already
 * locked, it is like a passthrough. If another thread already acquired
 * the lock, then the function blocks until the other thread is done
 * with the logger.
 *
 * \todo
 * This locking system is not exception safe. If one of the functions
 * called to generate the log message throws, then we will stay locked.
 */
void logger::lock()
{
    int err(pthread_mutex_lock(&g_log_mutex));
    if(err != 0)
    {
        std::cerr << "fatal: the mutex lock in cppthread::logger::lock() generated error #"
                  << err
                  << std::endl;
        pthread_mutex_unlock(&g_log_mutex);
        std::terminate();
    }

    if(!g_log_recursive_initialized)
    {
        g_log_recursive_initialized = true;

        pthread_mutexattr_t mattr;
        err = pthread_mutexattr_init(&mattr);
        if(err != 0)
        {
            std::cerr << "fatal: a mutex attribute structure could not be initialized, error #"
                      << err
                      << std::endl;
            pthread_mutex_unlock(&g_log_mutex);
            std::terminate();
        }
        err = pthread_mutexattr_settype(&mattr, PTHREAD_MUTEX_RECURSIVE);
        if(err != 0)
        {
            std::cerr << "fatal: a mutex attribute structure type could not be setup, error #"
                      << err
                      << std::endl;
            pthread_mutex_unlock(&g_log_mutex);
            std::terminate();
        }
        err = pthread_mutex_init(&g_log_recursive_mutex, &mattr);
        if(err != 0)
        {
            std::cerr << "fatal: a mutex structure could not be initialized, error #"
                      << err
                      << std::endl;
            pthread_mutex_unlock(&g_log_mutex);
            std::terminate();
        }
        err = pthread_mutexattr_destroy(&mattr);
        if(err != 0)
        {
            std::cerr << "fatal: a mutex attribute structure could not be destroyed, error #"
                      << err
                      << std::endl;
            pthread_mutex_unlock(&g_log_mutex);
            std::terminate();
        }
    }
    err = pthread_mutex_unlock(&g_log_mutex);
    if(err != 0)
    {
        std::cerr << "fatal: a mutex unlock generated error #"
                  << err
                  << std::endl;
        std::terminate();
    }

    // we have to lock only once so we use a flag to know whether we're
    // already locked, if so, we unlock immediately (but we stil have
    // one lock in place)
    //
    err = pthread_mutex_lock(&g_log_recursive_mutex);
    if(err != 0)
    {
        std::cerr << "fatal: a mutex lock generated error #"
                  << err
                  << std::endl;
        std::terminate();
    }

    if(g_log_locked)
    {
        // it was already locked, so unlock (i.e. we only want to keep one
        // lock turned on at a time)
        //
        err = pthread_mutex_unlock(&g_log_recursive_mutex);
        if(err != 0)
        {
            std::cerr << "fatal: a mutex unlock generated error #"
                      << err
                      << std::endl;
            std::terminate();
        }
    }
    else
    {
        g_log_locked = true;
    }
}


/** \brief Unlock the logger once we are done with it.
 *
 * Whenever the end() function gets called, the logger reacts by sending
 * the collected message to the user defined callback or to std::cerr.
 *
 * Note that the number of calls to the lock are not limited. However,
 * the unlock() function is called only once in the end() function.
 * Attempting to unlock the logger more than once is a bug and undefined
 * behavior may ensue. The class tries to emit an error when that happens,
 * but it is unlikely to catch the error each time.
 */
void logger::unlock()
{
    if(!g_log_locked)
    {
        std::cerr << "fatal: logger::unlock() called with g_log_locked == false"
                  << std::endl;
        std::terminate();
    }

    g_log_locked = false;

    int err(pthread_mutex_unlock(&g_log_recursive_mutex));
    if(err != 0)
    {
        std::cerr << "fatal: a mutex unlock generated error #"
                  << err
                  << std::endl;
        pthread_mutex_unlock(&g_log_recursive_mutex);
        std::terminate();
    }
}


/** \brief Save the level at which to log this message.
 *
 * This function gets called whenever you apply a level. This is expected
 * as the very first parameter of the log. It may be used to shortcut
 * the addition of other message data to avoid wasting time.
 *
 * The supported levels are defined in the log_level_t enumeration:
 *
 * * log_level_t::debug
 * * log_level_t::info
 * * log_level_t::warning
 * * log_level_t::error
 * * log_level_t::fatal
 *
 * Note that the fatal error level has no specific effect. It just
 * displays a level of "fatal". If you want to stop the software,
 * you are in charge of calling std::terminate() or exit().
 *
 * \note
 * The snaplogger has a special handler you can setup to capture fatal
 * errors which allows you to exit your software when such an error
 * occurs. It uses an exception for the purpose.
 *
 * \param[in] level  The level this message represents.
 *
 * \return A reference to this logger.
 */
logger & logger::operator << (log_level_t const & level)
{
    if(level < log_level_t::debug
    || level > log_level_t::fatal)
    {
        throw invalid_log_level(
                      "unknown log level ("
                    + std::to_string(static_cast<int>(level))
                    + ").");
    }

    lock();
    f_level = level;
    ++f_counters[static_cast<int>(level)];
    return *this;
}


/** \brief Execute a function.
 *
 * This call accepts a special value representing a logger function which
 * gets called with the logger as a reference parameter.
 *
 * This is currently used by the end() function.
 *
 * \param[in] func  The function to call with this logger as parameter.
 *
 * \return A reference to this logger.
 */
logger & logger::operator << (logger & (*func)(logger &))
{
    lock();
    func(*this);
    return *this;
}


/** \brief Reset all the log message counters to zero.
 *
 * This function resets all the log message counters to zero. This is useful
 * if you run in a server and want to count the logs for one run of a process
 * opposed to forever while running.
 *
 * \todo
 * The counter functions are not thread safe.
 */
void logger::reset_counters()
{
    std::memset(f_counters, 0, sizeof(f_counters));
}


/** \brief Get one of the level counters.
 *
 * WHenever a log is sent to the cppthread logger, one of its counter
 * gets incremented by 1. This is useful if you want to know whether
 * error messages were sent to the logger, see the get_errors() function
 * too as it includes a total of all the errors that happened.
 *
 * This function is useful to check the number of debug and info messages
 * that were processed.
 *
 * \todo
 * The counter functions are not thread safe.
 *
 * \param[in] level  The level to get the counter from.
 *
 * \return The number of times that level received a log message.
 *
 * \sa get_errors()
 * \sa get_warnings()
 */
std::uint32_t logger::get_counter(log_level_t level) const
{
    if(level < log_level_t::debug
    || level > log_level_t::fatal)
    {
        throw invalid_log_level(
                      "unknown log level ("
                    + std::to_string(static_cast<int>(level))
                    + ").");
    }

    return f_counters[static_cast<int>(level)];
}


/** \brief Get the number of errors that occurred so far.
 *
 * This function returns the total number of errors and fatal errors that were
 * sent to the cppthread logger.
 *
 * \todo
 * The counter functions are not thread safe.
 *
 * \return The number of errors generated so far.
 *
 * \sa get_counter()
 * \sa get_warnings()
 */
std::uint32_t logger::get_errors() const
{
    return f_counters[static_cast<int>(log_level_t::error)]
         + f_counters[static_cast<int>(log_level_t::fatal)];
}


/** \brief Get the number of warnings that occurred so far.
 *
 * This function returns the number of warnings that were sent to the
 * cppthread logger.
 *
 * \todo
 * The counter functions are not thread safe.
 *
 * \return The number of warnings generated so far.
 *
 * \sa get_counter()
 * \sa get_errors()
 */
std::uint32_t logger::get_warnings() const
{
    return f_counters[static_cast<int>(log_level_t::warning)];
}


/** \brief End the logger's message.
 *
 * This function is called whenever you apply the end() function to
 * the logger. It processes the message and sends it to the log
 * callback function or prints it to std::cerr.
 *
 * \note
 * If not callback was setup, the function throws away any debug
 * messages and prints out the other messages to std::cerr.
 *
 * \note
 * The log system has a lock in place whenever you start sending log
 * data. This function unlocks the logger before returning. It is
 * also exception safe.
 *
 * \return A reference to the logger object.
 */
logger & logger::end()
{
    // the std::cerr requires a lock so we keep the logger locked
    //
    try
    {
        if(g_log_callback != nullptr)
        {
            g_log_callback(f_level, f_log.str());
        }
        else if(f_level >= log_level_t::info)
        {
            std::cerr << to_string(f_level)
                      << ": "
                      << f_log.str()
                      << std::endl;
        }

        f_log.str(std::string());
    }
    catch(...)
    {
        unlock();
        throw;
    }

    unlock();

    return *this;
}


/** \brief Convert a log level to a string.
 *
 * This function transforms a log_level_t value to a string which can then
 * be used in a log message.
 *
 * \exception cppthread_invalid_error
 * If the log level is not one of the know log levels, then the function
 * raises this exception.
 *
 * \param[in] level  The message log level to convert to a string.
 *
 * \return A string representing the log level.
 */
std::string to_string(log_level_t level)
{
    switch(level)
    {
    case log_level_t::debug:
        return "debug";

    case log_level_t::info:
        return "info";

    case log_level_t::warning:
        return "warning";

    case log_level_t::error:
        return "error";

    case log_level_t::fatal:
        return "fatal";

    case log_level_t::LOG_LEVEL_SIZE:
        break;

    }

    throw invalid_error("unknown log level ("
                                 + std::to_string(static_cast<int>(level))
                                 + ")");
}


/** \fn logger::operator << (T const & v)
 * \brief Send any type of data to the logger.
 *
 * This operator allows to send data of type T to the logger.
 *
 * The logger makes use of a stringstream to generate the final message.
 * The type T must be a type that the stringstream supports. In most
 * cases, these are the types that the iostream supports.
 *
 * \param[in] v  The value to be output to this log message.
 *
 * \return A reference to this logger.
 */


/** \enum log_level_t
 * \brief The log level or severity.
 *
 * How important/severe the log message is.
 *
 * \warning
 * Note that logging a message with level fatal does not stop your program.
 * It's just a log level. You are responsible for stopping your program
 * if the error is indeed fatal.
 */


/** \var logger::f_level
 * \brief The level of this message.
 *
 * This variable member holds the level of the message. The level can
 * be specified within the set of `<<` operators.
 *
 * The default is to display informational, warning, error, and fatal
 * error messages to the error output (stderr). Other messages (debug)
 * get dropped. If you have a callback assigned (i.e. for example, if
 * you use snaplogger in your application), then all the messages get
 * redirected to that callback.
 */


/** \var logger::f_log
 * \brief The log message.
 *
 * This variable member is a stringstream which holds the current message.
 * Once the end() is sent, it outputs the f_log.str() message.
 *
 * \note
 * In order for messages to not criss-cross each other, the implementation
 * makes use of a global lock. That means only one thread can be sending
 * a log message at a time. The unlock() happens when the end() function
 * gets called.
 */


/** \fn end(logger & l)
 * \brief Close a log statement.
 *
 * This function is used to simplified the end of a log statement:
 *
 * \code
 *     int err(errno);
 *
 *     log << cppthread::log_level_t::fatal
 *         << "the initialization failed with errno = "
 *         << err
 *         << cppthread::end;
 * \endcode
 *
 * The result is a call to the logger::end() function which sends the message
 * to the logger current output.
 *
 * \param[in] l  A reference to the logger.
 *
 * \return A reference to the logger.
 */


/** \typedef log_callback
 * \brief The log callback type definition.
 *
 * By default, log messages will be sent to your console using std::cerr.
 * By setting up a log_callback function instead, it will be sent to
 * your function.
 *
 * \param[in] level  The level (severity) of this log message.
 * \param[in] message  The message to be logged.
 */


} // namespace cppthread
// vim: ts=4 sw=4 et
